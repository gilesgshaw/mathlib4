import Lean.Elab.DefView
import Lean.Util.CollectAxioms
import ImportGraph.Imports
import ImportGraph.RequiredModules
import Mathlib.Tactic.Linter.Header

/-! # `#min_imports in` a command to find minimal imports

`#min_imports in stx` scans the syntax `stx` to find a collection of minimal imports that should be
sufficient for `stx` to make sense.
If `stx` is a command, then it also elaborates `stx` and, in case it is a declaration, then
it also finds the imports implied by the declaration.

Unlike the related `#find_home`, this command takes into account notation and tactic information.

## Limitations

Parsing of `attribute`s is hard and the command makes minimal effort to support them.
Here is an example where the command fails to notice a dependency:
```lean
import Mathlib.Data.Sym.Sym2.Init -- the actual minimal import
import Aesop.Frontend.Attribute   -- the import that `#min_imports in` suggests

import Mathlib.Tactic.MinImports

-- import Aesop.Frontend.Attribute
#min_imports in
@[aesop (rule_sets := [Sym2]) [safe [constructors, cases], norm]]
inductive Rel (α : Type) : α × α → α × α → Prop
  | refl (x y : α) : Rel _ (x, y) (x, y)
  | swap (x y : α) : Rel _ (x, y) (y, x)

-- `import Mathlib.Data.Sym.Sym2.Init` is not detected by `#min_imports in`.
```

## Todo

*Examples*
When parsing an `example`, `#min_imports in` retrieves all the information that it can from the
`Syntax` of the `example`, but, since the `example` is not added to the environment, it fails
to retrieve any `Expr` information about the proof term.
It would be desirable to make `#min_imports in example ...` inspect the resulting proof and
report imports, but this feature is missing for the moment.

*Using `InfoTrees`*
It may be more efficient (not necessarily in terms of speed, but of simplicity of code),
to inspect the `InfoTrees` for each command and retrieve information from there.
I have not looked into this yet.
-/

open Lean Elab Command

namespace Mathlib.Command.MinImports'

/-- `getSyntaxNodeKinds stx` takes a `Syntax` input `stx` and returns the `NameSet` of all the
`SyntaxNodeKinds` and all the identifiers contained in `stx`. -/
partial
def getSyntaxNodeKinds : Syntax → NameSet
  | .node _ kind args =>
    ((args.map getSyntaxNodeKinds).foldl (NameSet.append · ·) {}).insert kind
  | .ident _ _ nm _ => NameSet.empty.insert nm
  | _ => {}

/-- Extracts the names of the declarations in `env` on which `decl` depends. -/
def getVisited (decl : Name) : CommandElabM NameSet := do
  unless (← hasConst decl) do
    return {}
  -- without resetting the state, the "unused tactics" linter gets confused?
  let st ← get
  liftCoreM decl.transitivelyUsedConstants <* set st

/-- `getId stx` takes as input a `Syntax` `stx`.
If `stx` contains a `declId`, then it returns the `ident`-syntax for the `declId`.
If `stx` is a nameless instance, then it also tries to fetch the `ident` for the instance.
Otherwise it returns `.missing`. -/
def getId (stx : Syntax) : CommandElabM Syntax := do
  -- If the command contains a `declId`, we use the implied `ident`.
  match stx.find? (·.isOfKind ``Lean.Parser.Command.declId) with
    | some declId => return declId[0]
    | none =>
      -- Otherwise, the command could be a nameless `instance`.
      match stx.find? (·.isOfKind ``Lean.Parser.Command.instance) with
        | none => return .missing
        | some stx => do
          -- if it is a nameless `instance`, we retrieve the autogenerated name
          let dv ← mkDefViewOfInstance {} stx
          return dv.declId[0]

/-- `getIds stx` extracts all identifiers, collecting them in a `NameSet`. -/
partial
def getIds : Syntax → NameSet
  | .node _ _ args => (args.map getIds).foldl (·.append ·) {}
  | .ident _ _ nm _ => NameSet.empty.insert nm
  | _ => {}

/-- `getAttrNames stx` extracts `attribute`s from `stx`.
It does not collect `simp`, `ext`, `to_additive`.
It should collect almost all other attributes, e.g., `fun_prop`. -/
def getAttrNames (stx : Syntax) : NameSet :=
  match stx.find? (·.isOfKind ``Lean.Parser.Term.attributes) with
    | none => {}
    | some stx => getIds stx

/-- `getAttrs env stx` returns all attribute declaration names contained in `stx` and registered
in the `Environment `env`. -/
def getAttrs (env : Environment) (stx : Syntax) : NameSet :=
  Id.run do
  let mut new : NameSet := {}
  for attr in (getAttrNames stx) do
    match getAttributeImpl env attr with
      | .ok attr => new := new.insert attr.ref
      | .error .. => pure ()
  return new

/-- `previousInstName nm` takes as input a name `nm`, assuming that it is the name of an
auto-generated "nameless" `instance`.
If `nm` ends in `..._n`, where `n` is a number, it returns the same name, but with `_n` replaced
by `_(n-1)`, unless `n ≤ 1`, in which case it simply removes the `_n` suffix.
-/
def previousInstName : Name → Name
  | nm@(.str init tail) =>
    let last := tail.takeRightWhile (· != '_')
    let newTail := match last.toNat? with
                    | some (n + 2) => s!"_{n + 1}"
                    | _ => ""
    let newTailPrefix := tail.dropRightWhile (· != '_')
    if newTailPrefix.isEmpty then nm else
    let newTail :=
      (if newTailPrefix.back == '_' then newTailPrefix.dropRight 1 else newTailPrefix) ++ newTail
    .str init newTail
  | nm => nm

#check mkDeclName

/--
`getDeclName cmd id` takes a `Syntax` input `cmd` and returns the `Name` of the declaration defined
by `cmd`.
-/
def getDeclName (cmd : Syntax) : CommandElabM Name := do
  let ns ← getCurrNamespace
  let id1 ← getId cmd
  let id2 := mkIdentFrom id1 (previousInstName id1.getId)
  logInfo m! "{id1} → {id2}"
  let some declStx := cmd.find? (·.isOfKind ``Parser.Command.declaration) | pure default
  let some modifiersStx := declStx.find? (·.isOfKind ``Parser.Command.declModifiers) | pure default
  let modifiers : TSyntax ``Parser.Command.declModifiers := ⟨modifiersStx⟩
  -- the `get`/`set` state catches issues with elaboration of, for instance, `scoped` attributes
  let s ← get
  let modifiers ← elabModifiers modifiers
  set s
  liftCoreM do (
    -- Try applying the algorithm in `Lean.mkDeclName` to attach a namespace to the name.
    -- Unfortunately calling `Lean.mkDeclName` directly won't work: it will complain that there is
    -- already a declaration with this name.
    (do
      let shortName := id2.getId
      let view := extractMacroScopes shortName
      let name := view.name
      let isRootName := (`_root_).isPrefixOf name
      let mut fullName := if isRootName then
        { view with name := name.replacePrefix `_root_ Name.anonymous }.review
      else
        ns ++ shortName
      -- Apply name visibility rules: private names get mangled.
      match modifiers.visibility with
      | .private => return mkPrivateName (← getEnv) fullName
      | _ => return fullName) <|>
    -- try the visible name or the current "nameless" `instance` name
    realizeGlobalConstNoOverload id1 <|>
    -- otherwise, guess what the previous "nameless" `instance` name was
    realizeGlobalConstNoOverload id2 <|>
    -- failing everything, use the current namespace followed by the visible name
    return ns ++ id2.getId)

/-- `getAllDependencies cmd id` takes a `Syntax` input `cmd` and returns the `NameSet` of all the
declaration names that are implied by
* the `SyntaxNodeKinds`,
* the attributes of `cmd` (if there are any),
* the identifiers contained in `cmd`,
* if `cmd` adds a declaration `d` to the environment, then also all the module names implied by `d`.
The argument `id` is expected to be an identifier.
It is used either for the internally generated name of a "nameless" `instance` or when parsing
an identifier representing the name of a declaration.

Note that the return value does not contain dependencies of the dependencies;
you can use `Lean.NameSet.transitivelyUsedConstants` to get those.
-/
def getAllDependencies (cmd id : Syntax) :
    CommandElabM NameSet := do
  let env ← getEnv
  -- We collect the implied declaration names, the `SyntaxNodeKinds` and the attributes.
  let result := (← getVisited (←getDeclName cmd))
              |>.append (← getVisited id.getId)
              |>.append (getSyntaxNodeKinds cmd)
              |>.append (getAttrs env cmd)
  logInfo m! "{id.getId}\n{(←getDeclName cmd)}"
  --logInfo m! "{id}\n{cmd}\n{result.toArray.qsort Name.lt}"
  return result

/-- `getAllImports cmd id` takes a `Syntax` input `cmd` and returns the `NameSet` of all the
module names that are implied by
* the `SyntaxNodeKinds`,
* the attributes of `cmd` (if there are any),
* the identifiers contained in `cmd`,
* if `cmd` adds a declaration `d` to the environment, then also all the module names implied by `d`.
The argument `id` is expected to be an identifier.
It is used either for the internally generated name of a "nameless" `instance` or when parsing
an identifier representing the name of a declaration.
-/
def getAllImports (cmd id : Syntax) (dbg? : Bool := false) :
    CommandElabM NameSet := do
  let env ← getEnv
  -- We collect the implied declaration names, the `SyntaxNodeKinds` and the attributes.
  let ts ← getAllDependencies cmd id
  if dbg? then dbg_trace "{ts.toArray.qsort Name.lt}"
  let mut hm : Std.HashMap Nat Name := {}
  for imp in env.header.moduleNames do
    hm := hm.insert ((env.getModuleIdx? imp).getD default) imp
  let mut fins : NameSet := {}
  for t in ts do
    let new := match env.getModuleIdxFor? t with
      | some t => (hm.get? t).get!
      | none   => .anonymous -- instead of `getMainModule`, we omit the current module
    if !fins.contains new then fins := fins.insert new
  --logInfo m! "{id}\n{cmd}\n{fins.toArray.qsort Name.lt}"
  return fins.erase .anonymous

/-- `getIrredundantImports env importNames` takes an `Environment` and a `NameSet` as inputs.
Assuming that `importNames` are module names,
it returns the `NameSet` consisting of a minimal collection of module names whose transitive
closure is enough to parse (and elaborate) `cmd`. -/
def getIrredundantImports (env : Environment) (importNames : NameSet) : NameSet :=
  importNames.diff (env.findRedundantImports importNames.toArray)

/-- `minImpsCore stx id` is the internal function to elaborate the `#min_imports in` command.
It collects the irredundant imports to parse and elaborate `stx` and logs
```lean
import A
import B
...
import Z
```
The `id` input is expected to be the name of the declaration that is currently processed.
It is used to provide the internally generated name for "nameless" `instance`s.
-/
def minImpsCore (stx id : Syntax) : CommandElabM Unit := do
    let tot := getIrredundantImports (← getEnv) (← getAllImports stx id)
    let fileNames := tot.toArray.qsort Name.lt
    logInfoAt (← getRef) m!"{"\n".intercalate (fileNames.map (s!"import {·}")).toList}"

/-- `#min_imports in cmd` scans the syntax `cmd` and the declaration obtained by elaborating `cmd`
to find a collection of minimal imports that should be sufficient for `cmd` to work. -/
syntax (name := minImpsStx) "#min_imports" " in " command : command

@[inherit_doc minImpsStx]
syntax "#min_imports" " in " term : command

elab_rules : command
  | `(#min_imports in $cmd:command) => do
    -- In case `cmd` is a "nameless" `instance`, we produce its name.
    -- It is important that this is collected *before* adding the declaration to the environment,
    -- since `getId` probes the name-generator using the current environment: if the declaration
    -- were already present, `getId` would return a new name that does not clash with it!
    let id ← getId cmd
    Elab.Command.elabCommand cmd <|> pure ()
    minImpsCore cmd id
  | `(#min_imports in $cmd:term) => minImpsCore cmd cmd

end Mathlib.Command.MinImports'


/-! # The `minImports` linter

The `minImports` linter incrementally computes the minimal imports needed for each file to build.
Whenever it detects that a new command requires an increase in the (transitive) imports that it
computed so far, it emits a warning mentioning the bigger minimal imports.

Unlike the related `#min_imports` command, the linter takes into account notation and tactic
information.
It also works incrementally, accumulating increasing import information.
This is better suited, for instance, to split files.
-/

open Lean Elab Command Linter

/-!
#  The "minImports" linter

The "minImports" linter tracks information about minimal imports over several commands.
-/

namespace Mathlib.Linter'

/--
`ImportState` is the structure keeping track of the data that the `minImports` linter uses.
* `transClosure` is the import graph of the current file.
* `minImports` is the `NameSet` of minimal imports to build the file up to the current command.
* `importSize` is the number of transitive imports to build the file up to the current command.
-/
structure ImportState where
  /-- The transitive closure of the import graph of the current file.  The value is `none` only at
  initialization time, as the linter immediately sets it to its value for the current file. -/
  transClosure : Option (NameMap NameSet) := none
  /-- The minimal imports needed to build the file up to the current command. -/
  minImports   : NameSet := {}
  /-- The number of transitive imports needed to build the file up to the current command. -/
  importSize   : Nat := 0
  deriving Inhabited

/--
`minImportsRef` keeps track of cumulative imports across multiple commands, using `ImportState`.
-/
initialize minImportsRef : IO.Ref ImportState ← IO.mkRef {}

/-- `#reset_min_imports` sets to empty the current list of cumulative imports. -/
elab "#reset_min_imports" : command => minImportsRef.set {}

/--
The `minImports` linter incrementally computes the minimal imports needed for each file to build.
Whenever it detects that a new command requires an increase in the (transitive) imports that it
computed so far, it emits a warning mentioning the bigger minimal imports.

Unlike the related `#min_imports` command, the linter takes into account notation and tactic
information.
It also works incrementally, providing information that is better suited, for instance, to split
files.

Another important difference is that the `minImports` *linter* starts counting imports from
where the option is set to `true` *downwards*, whereas the `#min_imports` *command* looks at the
imports needed from the command *upwards*.
-/
register_option linter.minImports' : Bool := {
  defValue := false
  descr := "enable the minImports linter"
}

/-- The `linter.minImports.increases` regulates whether the `minImports` linter reports the
change in number of imports, when it reports import changes.
Setting this option to `false` helps with test stability.
-/
register_option linter.minImports'.increases : Bool := {
  defValue := true
  descr := "enable reporting increase-size change in the minImports linter"
}

namespace MinImports

open Mathlib.Command.MinImports'

/-- `importsBelow tc ms` takes as input a `NameMap NameSet` `tc`, representing the
`transitiveClosure` of the imports of the current module, and a `NameSet` of module names `ms`.
It returns the modules that are transitively imported by `ms`, using the data in `tc`.
-/
def importsBelow (tc : NameMap NameSet) (ms : NameSet) : NameSet :=
  ms.fold (·.append <| tc.findD · default) ms

macro "#import_bumps" : command => `(
  -- We emit a message to prevent the `#`-command linter from flagging `#import_bumps`.
  run_cmd logInfo "Counting imports from here."
  set_option Elab.async false
  set_option linter.minImports true)

def minImports'Linter : Linter where run := withSetOptionIn fun stx ↦ do
    unless getLinterValue linter.minImports' (← getLinterOptions) do
      return
    if (← get).messages.hasErrors then
      return
    if stx == (← `(command| #import_bumps)) then return
    if stx == (← `(command| set_option $(mkIdent `linter.minImports) true)) then
      logInfo "Try using '#import_bumps', instead of manually setting the linter option: \
              the linter works best with linear parsing of the file and '#import_bumps' \
              also sets the `Elab.async` option to `false`."
      return
    let env ← getEnv
    -- the first time `minImportsRef` is read, it has `transClosure = none`;
    -- in this case, we set it to be the `transClosure` for the file.
    if (← minImportsRef.get).transClosure.isNone then
      minImportsRef.modify ({· with transClosure := env.importGraph.transitiveClosure})
    let impState ← minImportsRef.get
    let (importsSoFar, oldCumulImps) := (impState.minImports, impState.importSize)
    -- when the linter reaches the end of the file or `#exit`, it gives a report
    if #[``Parser.Command.eoi, ``Lean.Parser.Command.exit].contains stx.getKind then
      let explicitImportsInFile : NameSet :=
        .fromArray ((env.imports.map (·.module)).erase `Init) Name.quickCmp
      let newImps := importsSoFar.diff explicitImportsInFile
      let currentlyUnneededImports := explicitImportsInFile.diff importsSoFar
      -- we read the current file, to do a custom parsing of the imports:
      -- this is a hack to obtain some `Syntax` information for the `import X` commands
      let fname ← getFileName
      let contents ← IO.FS.readFile fname
      -- `impMods` is the syntax for the modules imported in the current file
      let (impMods, _) ← Parser.parseHeader (Parser.mkInputContext contents fname)
      for i in currentlyUnneededImports do
        match impMods.raw.find? (·.getId == i) with
          | some impPos => logWarningAt impPos m!"unneeded import '{i}'"
          | _ => dbg_trace f!"'{i}' not found"  -- this should be unreachable
      -- if the linter found new imports that should be added (likely to *reduce* the dependencies)
      if !newImps.isEmpty then
        -- format the imports prepending `import ` to each module name
        let withImport := (newImps.toArray.qsort Name.lt).map (s!"import {·}")
        -- log a warning at the first `import`, if there is one.
        logWarningAt ((impMods.raw.find? (·.isOfKind `import)).getD default)
          m!"-- missing imports\n{"\n".intercalate withImport.toList}"
    let id ← getId stx
    let newImports := getIrredundantImports env (← getAllImports stx id)
    let tot := (newImports.append importsSoFar)
    let redundant := env.findRedundantImports tot.toArray
    let currImports := tot.diff redundant
    let currImpArray := currImports.toArray.qsort Name.lt
    if currImpArray != #[] &&
       currImpArray ≠ importsSoFar.toArray.qsort Name.lt then
      let newCumulImps := -- We should always be in the situation where `getD` finds something
        (importsBelow (impState.transClosure.getD env.importGraph.transitiveClosure) tot).size
      minImportsRef.modify ({· with minImports := currImports, importSize := newCumulImps})
      let new := currImpArray.filter (!importsSoFar.contains ·)
      let redundant := importsSoFar.toArray.filter (!currImports.contains ·)
      -- to make `test` files more stable, we suppress the exact count of import changes if
      -- the `linter.minImports.increases` option is `false`
      let byCount :=  if getLinterValue linter.minImports'.increases (← getLinterOptions) then
                      m!"by {newCumulImps - oldCumulImps} "
                    else
                      m!""
      -- Linter.logLint linter.minImports' stx <|
      --   m!"Imports increased {byCount}to\n{currImpArray}\n\n\
      --     New imports: {new}\n" ++
      --       if redundant.isEmpty then m!"" else m!"\nNow redundant: {redundant}\n"

initialize addLinter minImports'Linter

end MinImports

end Mathlib.Linter'
